require "dotenv" # Load environment variables from .env file
# Load .env file if it exists, otherwise continue silently
Dotenv.load? # The ? makes it return nil instead of raising if file doesn't exist

require "./initialization" # Import the initialization helper - API testing
require "./tocry"
require "baked_file_handler"
require "./migrations"
require "ecr" # Required for render
require "baked_file_system"
require "docopt"
require "docopt-config"                 # Unified configuration management
require "./auth"                        # Add auth (defines Google OAuth routes and current_user helper)
require "./endpoints"                   # Add this line to include your new endpoints file
require "./auth_helpers"                # New: Contains authentication mode setup functions
require "./demo"                        # Demo mode functionality
require "./websocket_handler"           # WebSocket support for real-time synchronization
require "./mcp/kemal_handler"           # MCP (Model Context Protocol) integration
require "./services/rate_limit_service" # Rate limiting service
require "kemal-basic-auth"
require "kemal"
require "kemal-session"
require "sepia"

DOC = <<-DOCOPT
ToCry, a list of things To Do. Or Cry.

Usage:
  tocry [options]
  tocry (-h | --help)
  tocry --version

Options:
  -p PORT, --port=PORT                Port to listen on [default: 3000].
  -b ADDRESS, --bind=ADDRESS          Address to bind to [default: 127.0.0.1].
  -h --help                           Show this screen.
  --version                           Show version.
  --data-path=PATH                    Path to the data directory.
  --safe-mode                         Enable safe mode (checks data integrity).
  --demo                              Enable demo mode (in-memory storage with sample data).
  --no-mcp                            Disable MCP (Model Context Protocol) support.
  --unix-socket=PATH                  Use Unix socket at specified path instead of TCP.
  --ai-model=MODEL                    AI model to use for AI features [default: glm-4.5-flash]. See https://docs.z.ai/guides/overview/pricing for available models.
  --cache-size=SIZE                   Maximum number of objects to cache [default: 1000].
  --cache-ttl=SECONDS                 Cache time-to-live in seconds [default: 0].
  --no-cache                          Disable caching entirely.
  --generations                       Enable note version history (generations) support.
  --auth-user=USER                    Username for basic authentication.
  --auth-pass=PASSWORD                Password for basic authentication.
  --google-client-id=ID               Google OAuth client ID for authentication.
  --google-client-secret=SECRET       Google OAuth client secret for authentication.
  --session-secret=SECRET             Secret key for session management [default: auto-generated].
  --z-ai-api-key=KEY                  API key for Z.AI features.
  --rate-limit-enabled=BOOL           Enable rate limiting [default: true].
  --rate-limit-user=LIMIT            Rate limit per user [default: 100].
  --rate-limit-ai=LIMIT               Rate limit for AI endpoints [default: 10].
  --rate-limit-upload=LIMIT          Rate limit for file uploads [default: 5].
  --rate-limit-auth=LIMIT            Rate limit for authentication endpoints [default: 10].
  --config=PATH                       Path to configuration file (YAML or JSON).
DOCOPT

class Assets
  extend BakedFileSystem
  # Bake assets from the top-level assets directory (generated by build process)
  bake_folder "../assets"
end

# Configure Sepia cache settings based on unified configuration
def configure_cache_with_config(config)
  # Check if caching is disabled
  no_cache = !!config["--no-cache"]

  if no_cache
    ToCry::Log.info { "Caching disabled via --no-cache flag" }
    return
  end

  # Get cache size from unified configuration (CLI > env > config file > defaults)
  cache_size = config["--cache-size"]?.try(&.to_s.to_i) || 1000

  # Get cache TTL from unified configuration (CLI > env > config file > defaults)
  cache_ttl_seconds = config["--cache-ttl"]?.try(&.to_s.to_i) || 0

  # Convert TTL to Time::Span (0 means no expiration)
  cache_ttl = cache_ttl_seconds && cache_ttl_seconds > 0 ? cache_ttl_seconds.seconds : nil

  # Configure the global cache manager
  cache = Sepia::CacheManager.instance

  # Resize cache if needed (this handles the case where default cache was already used)
  if cache.max_size != cache_size
    cache.resize(cache_size)
    ToCry::Log.info { "Cache size set to #{cache_size} objects" }
  end

  # Note: TTL cannot be changed after cache creation, so we log this information
  if cache_ttl
    ToCry::Log.info { "Cache TTL set to #{cache_ttl_seconds} seconds" }
  else
    ToCry::Log.info { "Cache TTL: no expiration (objects cached indefinitely)" }
  end

  # Log cache configuration
  ToCry::Log.info { "Cache configured: size=#{cache_size}, ttl=#{cache_ttl_seconds}s, disabled=#{no_cache}" }

  # Log cache stats
  ToCry::Log.info { "Initial cache stats: #{cache.stats}" }
end

# This `main()`function is called from the top-level so it's code that
# always gets executed.

# ameba:disable Metrics/CyclomaticComplexity
def main
  # Get config file path from command line before parsing everything
  config_file = nil
  ARGV.each_with_index do |arg, i|
    if arg == "--config" && i + 1 < ARGV.size
      config_file = ARGV[i + 1]
      break
    end
  end

  # Parse unified configuration using docopt-config
  config = Docopt.docopt_config(
    doc: DOC,
    argv: ARGV,
    config_file_path: config_file,
    env_prefix: "TOCRY",
    help: true,
    version: ToCry::VERSION
  )

  ARGV.clear # Clear ARGV to prevent further processing by Crystal

  # Get configuration values with unified precedence (CLI > env > config file > defaults)
  data_path = config["--data-path"]?.try(&.as(String))
  if data_path.nil?
    # If no explicit data path provided, use user directory for non-root users
    # Check if we're root by checking if USER environment variable is "root"
    current_user = ENV["USER"]?
    if current_user == "root"
      data_path = "data"
    else
      # Use ~/.local/share/tocry for non-root users
      home_dir = ENV["HOME"]? || Dir.current
      data_path = File.join(home_dir, ".local", "share", "tocry")
    end
  end

  safe_mode = !!config["--safe-mode"]             # Parse --safe-mode argument as boolean
  demo_mode = !!config["--demo"]                  # Parse --demo argument as boolean
  generations_enabled = !!config["--generations"] # Parse --generations argument as boolean

  # Set environment variable for generations if flag is provided
  if generations_enabled
    ENV["USE_GENERATIONS"] = "true"
  end

  disable_mcp = !!config["--no-mcp"]         # Parse --no-mcp argument as boolean
  ai_model = config["--ai-model"].as(String) # Parse --ai-model argument

  # Parse authentication options (already handled by precedence in docopt-config)
  auth_user = config["--auth-user"]?.try(&.as(String))
  auth_pass = config["--auth-pass"]?.try(&.as(String))
  google_client_id = config["--google-client-id"]?.try(&.as(String))
  google_client_secret = config["--google-client-secret"]?.try(&.as(String))
  session_secret = config["--session-secret"]?.try(&.as(String))
  z_ai_api_key = config["--z-ai-api-key"]?.try(&.as(String))

  # Set environment variables for authentication if provided
  # This ensures existing authentication logic continues to work
  ENV["TOCRY_AUTH_USER"] = auth_user if auth_user
  ENV["TOCRY_AUTH_PASS"] = auth_pass if auth_pass
  ENV["GOOGLE_CLIENT_ID"] = google_client_id if google_client_id
  ENV["GOOGLE_CLIENT_SECRET"] = google_client_secret if google_client_secret
  ENV["SESSION_SECRET"] = session_secret if session_secret
  ENV["Z_AI_API_KEY"] = z_ai_api_key if z_ai_api_key

  # Parse rate limiting options (already handled by precedence in docopt-config)
  rate_limit_enabled = config["--rate-limit-enabled"]?.try { |v| v.to_s == "true" } || true
  rate_limit_user = config["--rate-limit-user"]?.try(&.to_s.to_i) || 100
  rate_limit_ai = config["--rate-limit-ai"]?.try(&.to_s.to_i) || 10
  rate_limit_upload = config["--rate-limit-upload"]?.try(&.to_s.to_i) || 5
  rate_limit_auth = config["--rate-limit-auth"]?.try(&.to_s.to_i) || 10

  # Set environment variables for rate limiting if provided via CLI
  # Convert integer limits to rate strings (requests/time_window_seconds)
  ENV["TOCRY_RATE_LIMITING_ENABLED"] = rate_limit_enabled.to_s
  ENV["TOCRY_RATE_LIMIT_USER"] = "#{rate_limit_user}/3600"     # Per hour
  ENV["TOCRY_RATE_LIMIT_AI"] = "#{rate_limit_ai}/3600"         # Per hour
  ENV["TOCRY_RATE_LIMIT_UPLOAD"] = "#{rate_limit_upload}/3600" # Per hour
  ENV["TOCRY_RATE_LIMIT_AUTH"] = "#{rate_limit_auth}/900"      # Per 15 minutes

  # Configure cache settings using unified config
  configure_cache_with_config(config)

  # Log config file usage
  if config_file
    ToCry::Log.info { "Using configuration file: #{config_file}" }
  end

  # Initialize data environment using the helper
  ToCry.board_manager = ToCry::Initialization.setup_data_environment(data_path, safe_mode, true, demo_mode)

  if demo_mode
    ToCry::Log.info { "Demo mode enabled: using in-memory storage with sample data" }
  else
    ToCry::Log.info { "Using data path: #{data_path}" }
  end
  ToCry::Log.info { "Safe mode enabled: #{safe_mode}" }

  # Set global MCP status and log
  ToCry.mcp_enabled = !disable_mcp
  if disable_mcp
    ToCry::Log.info { "MCP (Model Context Protocol) support disabled" }
  else
    ToCry::Log.info { "MCP (Model Context Protocol) support enabled" }
  end

  # Set AI model and log
  ToCry.ai_model = ai_model
  ToCry::Log.info { "AI model configured: #{ai_model}" }

  # Check for Unix socket option first
  unix_socket_path = config["--unix-socket"]?.try(&.as(String))

  if unix_socket_path
    # Unix socket mode - ignore port and bind address
    ToCry::Log.info { "Using Unix socket: #{unix_socket_path}" }
    port = 0          # Not used in Unix socket mode
    bind_address = "" # Not used in Unix socket mode
  else
    # TCP mode - parse port and bind address
    port = config["--port"]?.try(&.to_s.to_i) || 3000
    bind_address = config["--bind"].as(String)
    ToCry::Log.info { "Using TCP: #{bind_address}:#{port}" }
  end

  # Add a handler to serve user-uploaded images from the configured data path.
  # This replaces the `public_folder` macro.
  # Skip this in demo mode since we don't store actual files
  unless ToCry::Demo.demo_mode?
    uploads_path = File.join(data_path, "uploads")
    add_handler Kemal::StaticFileHandler.new(uploads_path)
    # Ensure the uploads directory exists to prevent issues.
    unless Dir.exists?(uploads_path)
      ToCry::Log.warn { "Uploads directory not found at '#{uploads_path}'. Creating it now." }
      FileUtils.mkdir_p(uploads_path)
    end

    # Ensure attachments base directory exists
    attachments_path = File.join(data_path, "uploads", "attachments")
    unless Dir.exists?(attachments_path)
      ToCry::Log.info { "Creating attachments directory at '#{attachments_path}'" }
      FileUtils.mkdir_p(attachments_path)
    end
  end

  # Log at debug level. Probably worth making it configurable.

  Log.setup(:debug) # Or use Log.setup_from_env for more flexibility
  ToCry::Log.info { "Starting ToCry server on #{bind_address}:#{port}" }
  # Start kemal listening on the right address

  # Enable gzip compression for all responses
  # This significantly reduces bandwidth usage for text-based content (HTML, CSS, JS, JSON)
  # Kemal automatically compresses responses > 860 bytes when client accepts gzip encoding
  gzip true

  # On every request, ensure the current user's data directory exists.
  before_all do |env|
    ToCry.ensure_user_directory_exists(env)
  end

  # Determine authentication mode based on environment variables
  use_google_auth = ENV["GOOGLE_CLIENT_ID"]? && ENV["GOOGLE_CLIENT_SECRET"]?
  use_basic_auth = ENV["TOCRY_AUTH_USER"]? && ENV["TOCRY_AUTH_PASS"]?

  Kemal.config.host_binding = bind_address

  # Configure sessions using the kemal-session shard.
  # A session secret is always required if sessions are used anywhere in the application.
  Kemal::Session.config do |session_config|
    session_config.samesite = HTTP::Cookie::SameSite::Strict
    session_config.cookie_name = "session_id"
    session_config.secret = ENV.fetch("SESSION_SECRET", "a_very_long_and_secret_key_that_should_be_changed")
    session_config.engine = Kemal::Session::MemoryEngine.new
  end
  ToCry::Log.info { "Session support enabled." }

  if use_google_auth
    setup_google_auth_mode
  elsif use_basic_auth
    setup_basic_auth_mode
  else # No Auth
    setup_no_auth_mode
  end

  # Initialize rate limiting service
  rate_limit_config = ToCry::RateLimitConfig.load
  rate_limit_service = ToCry::RateLimitService.new(rate_limit_config)

  # Log rate limiting configuration
  ToCry::Log.info do
    config_info = rate_limit_config.to_h.map { |k, v| "#{k}: #{v}" }.join(", ")
    "Rate limiting initialized - #{config_info}"
  end

  # Add rate limiting middleware
  before_all do |env|
    # Get user ID from session (will be "root" for no-auth mode)
    user_id = env.session.string?("user_id")

    if user_id
      # Extract endpoint path for rate limiting decisions
      endpoint = env.request.path

      # Check if request is allowed by rate limiting
      unless rate_limit_service.allow_request?(user_id, nil, endpoint)
        response = {
          "error"       => "Rate limit exceeded",
          "message"     => "Too many requests. Please try again later.",
          "retry_after" => 60,
        }.to_json
        halt env, status_code: 429, response: response
      end
    end
  end

  # Serve OpenAPI spec statically
  get "/api/openapi.json" do |env|
    env.response.content_type = "application/json"
    File.read("openapi.json")
  end

  # Serve OpenAPI docs using Scalar
  get "/api/docs" do |env|
    env.response.content_type = "text/html"
    <<-HTML
    <!DOCTYPE html>
    <html>
    <head>
      <title>ToCry API Documentation</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
    </head>
    <body>
      <script
        id="api-reference"
        data-url="/api/openapi.json">
      </script>
      <script src="https://cdn.jsdelivr.net/npm/@scalar/api-reference"></script>
    </body>
    </html>
    HTML
  end

  # Serve the main application HTML for the root path
  get "/" do |_|
    # Default to reactive UI
    render "templates/app.ecr"
  end

  # Demo mode: serve placeholder images for demo uploads
  get "/demo/image/:upload_id" do |env|
    upload_id = env.params.url["upload_id"]

    # Only serve demo images if we're actually in demo mode
    unless ToCry::Demo.demo_mode?
      next env.response.status = HTTP::Status::NOT_FOUND
    end

    # Create a simple placeholder image (SVG)
    placeholder_svg = <<-SVG
    <svg width="200" height="150" xmlns="http://www.w3.org/2000/svg">
      <rect width="200" height="150" fill="#e0e0e0" stroke="#ccc" stroke-width="2"/>
      <text x="100" y="75" text-anchor="middle" font-family="Arial" font-size="14" fill="#666">Demo Image</text>
      <text x="100" y="95" text-anchor="middle" font-family="Arial" font-size="10" fill="#999">#{upload_id[0..7]}...</text>
    </svg>
    SVG

    env.response.content_type = "image/svg+xml"
    env.response.headers["Cache-Control"] = "public, max-age=3600"
    placeholder_svg
  end

  # WebSocket endpoint for real-time board synchronization
  # Usage: /ws?board=board-name
  ws "/ws" do |socket, env|
    ToCry::WebSocketHandler.handle_websocket(socket, env)
  end

  baked_asset_handler = BakedFileHandler::BakedFileHandler.new(Assets)
  add_handler baked_asset_handler

  # Configure server based on socket type
  if unix_socket_path
    # Remove existing socket file if it exists
    File.delete(unix_socket_path) if File.exists?(unix_socket_path)

    ToCry::Log.info { "Starting ToCry server on Unix socket #{unix_socket_path}" }

    # Use Kemal's built-in Unix socket support
    Kemal.run do |server_config|
      # Don't bind to TCP port when using Unix socket
      server_config.port = 0
      if server = server_config.server
        server.bind_unix(unix_socket_path)
      else
        ToCry::Log.error { "Failed to get server instance for Unix socket binding" }
      end
    end
  else
    # Use standard TCP server
    Kemal.run(port: port)
  end
end

main()
